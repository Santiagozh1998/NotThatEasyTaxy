{"ast":null,"code":"/* \n * Leaflet Control Search v2.9.7 - 2019-01-14 \n * \n * Copyright 2019 Stefano Cudini \n * stefano.cudini@gmail.com \n * http://labs.easyblog.it/ \n * \n * Licensed under the MIT license. \n * \n * Demo: \n * http://labs.easyblog.it/maps/leaflet-search/ \n * \n * Source: \n * git@github.com:stefanocudini/leaflet-search.git \n * \n */\n\n/*\n\tName\t\t\t\t\tData passed\t\t\t   Description\n\n\tManaged Events:\n\t search:locationfound\t{latlng, title, layer} fired after moved and show markerLocation\n\t search:expanded\t\t{}\t\t\t\t\t   fired after control was expanded\n\t search:collapsed\t\t{}\t\t\t\t\t   fired after control was collapsed\n \t search:cancel\t\t\t{}\t\t\t\t\t   fired after cancel button clicked\n\n\tPublic methods:\n\t setLayer()\t\t\t\tL.LayerGroup()         set layer search at runtime\n\t showAlert()            'Text message'         show alert message\n\t searchText()\t\t\t'Text searched'        search text by external code\n*/\n//TODO implement can do research on multiple sources layers and remote\t\t\n//TODO history: false,\t\t//show latest searches in tooltip\t\t\n//FIXME option condition problem {autoCollapse: true, markerLocation: true} not show location\n//FIXME option condition problem {autoCollapse: false }\n//\n//TODO here insert function  search inputText FIRST in _recordsCache keys and if not find results.. \n//  run one of callbacks search(sourceData,jsonpUrl or options.layer) and run this.showTooltip\n//\n//TODO change structure of _recordsCache\n//\tlike this: _recordsCache = {\"text-key1\": {loc:[lat,lng], ..other attributes.. }, {\"text-key2\": {loc:[lat,lng]}...}, ...}\n//\tin this mode every record can have a free structure of attributes, only 'loc' is required\n//TODO important optimization!!! always append data in this._recordsCache\n//  now _recordsCache content is emptied and replaced with new data founded\n//  always appending data on _recordsCache give the possibility of caching ajax, jsonp and layersearch!\n//\n//TODO here insert function  search inputText FIRST in _recordsCache keys and if not find results.. \n//  run one of callbacks search(sourceData,jsonpUrl or options.layer) and run this.showTooltip\n//\n//TODO change structure of _recordsCache\n//\tlike this: _recordsCache = {\"text-key1\": {loc:[lat,lng], ..other attributes.. }, {\"text-key2\": {loc:[lat,lng]}...}, ...}\n//\tin this way every record can have a free structure of attributes, only 'loc' is required\n(function (factory) {\n  if (typeof define === 'function' && define.amd) {\n    //AMD\n    define(['leaflet'], factory);\n  } else if (typeof module !== 'undefined') {\n    // Node/CommonJS\n    module.exports = factory(require('leaflet'));\n  } else {\n    // Browser globals\n    if (typeof window.L === 'undefined') throw 'Leaflet must be loaded first';\n    factory(window.L);\n  }\n})(function (L) {\n  L.Control.Search = L.Control.extend({\n    includes: L.version[0] === '1' ? L.Evented.prototype : L.Mixin.Events,\n    options: {\n      url: '',\n      //url for search by ajax request, ex: \"search.php?q={s}\". Can be function to returns string for dynamic parameter setting\n      layer: null,\n      //layer where search markers(is a L.LayerGroup)\t\t\t\t\n      sourceData: null,\n      //function to fill _recordsCache, passed searching text by first param and callback in second\t\t\t\t\n      //TODO implements uniq option 'sourceData' to recognizes source type: url,array,callback or layer\t\t\t\t\n      jsonpParam: null,\n      //jsonp param name for search by jsonp service, ex: \"callback\"\n      propertyLoc: 'loc',\n      //field for remapping location, using array: ['latname','lonname'] for select double fields(ex. ['lat','lon'] ) support dotted format: 'prop.subprop.title'\n      propertyName: 'title',\n      //property in marker.options(or feature.properties for vector layer) trough filter elements in layer,\n      formatData: null,\n      //callback for reformat all data from source to indexed data object\n      filterData: null,\n      //callback for filtering data from text searched, params: textSearch, allRecords\n      moveToLocation: null,\n      //callback run on location found, params: latlng, title, map\n      buildTip: null,\n      //function to return row tip html node(or html string), receive text tooltip in first param\n      container: '',\n      //container id to insert Search Control\t\t\n      zoom: null,\n      //default zoom level for move to location\n      minLength: 1,\n      //minimal text length for autocomplete\n      initial: true,\n      //search elements only by initial text\n      casesensitive: false,\n      //search elements in case sensitive text\n      autoType: true,\n      //complete input with first suggested result and select this filled-in text.\n      delayType: 400,\n      //delay while typing for show tooltip\n      tooltipLimit: -1,\n      //limit max results to show in tooltip. -1 for no limit, 0 for no results\n      tipAutoSubmit: true,\n      //auto map panTo when click on tooltip\n      firstTipSubmit: false,\n      //auto select first result con enter click\n      autoResize: true,\n      //autoresize on input change\n      collapsed: true,\n      //collapse search control at startup\n      autoCollapse: false,\n      //collapse search control after submit(on button or on tips if enabled tipAutoSubmit)\n      autoCollapseTime: 1200,\n      //delay for autoclosing alert and collapse after blur\n      textErr: 'Location not found',\n      //error message\n      textCancel: 'Cancel',\n      //title in cancel button\t\t\n      textPlaceholder: 'Search...',\n      //placeholder value\t\t\t\n      hideMarkerOnCollapse: false,\n      //remove circle and marker on search control collapsed\t\t\n      position: 'topleft',\n      marker: {\n        //custom L.Marker or false for hide\n        icon: false,\n        //custom L.Icon for maker location or false for hide\n        animate: true,\n        //animate a circle over location found\n        circle: {\n          //draw a circle in location found\n          radius: 10,\n          weight: 3,\n          color: '#e03',\n          stroke: true,\n          fill: false\n        }\n      }\n    },\n    _getPath: function _getPath(obj, prop) {\n      var parts = prop.split('.'),\n          last = parts.pop(),\n          len = parts.length,\n          cur = parts[0],\n          i = 1;\n      if (len > 0) while ((obj = obj[cur]) && i < len) {\n        cur = parts[i++];\n      }\n      if (obj) return obj[last];\n    },\n    _isObject: function _isObject(obj) {\n      return Object.prototype.toString.call(obj) === \"[object Object]\";\n    },\n    initialize: function initialize(options) {\n      L.Util.setOptions(this, options || {});\n      this._inputMinSize = this.options.textPlaceholder ? this.options.textPlaceholder.length : 10;\n      this._layer = this.options.layer || new L.LayerGroup();\n      this._filterData = this.options.filterData || this._defaultFilterData;\n      this._formatData = this.options.formatData || this._defaultFormatData;\n      this._moveToLocation = this.options.moveToLocation || this._defaultMoveToLocation;\n      this._autoTypeTmp = this.options.autoType; //useful for disable autoType temporarily in delete/backspace keydown\n\n      this._countertips = 0; //number of tips items\n\n      this._recordsCache = {}; //key,value table! to store locations! format: key,latlng\n\n      this._curReq = null;\n    },\n    onAdd: function onAdd(map) {\n      this._map = map;\n      this._container = L.DomUtil.create('div', 'leaflet-control-search');\n      this._input = this._createInput(this.options.textPlaceholder, 'search-input');\n      this._tooltip = this._createTooltip('search-tooltip');\n      this._cancel = this._createCancel(this.options.textCancel, 'search-cancel');\n      this._button = this._createButton(this.options.textPlaceholder, 'search-button');\n      this._alert = this._createAlert('search-alert');\n      if (this.options.collapsed === false) this.expand(this.options.collapsed);\n\n      if (this.options.marker) {\n        if (this.options.marker instanceof L.Marker || this.options.marker instanceof L.CircleMarker) this._markerSearch = this.options.marker;else if (this._isObject(this.options.marker)) this._markerSearch = new L.Control.Search.Marker([0, 0], this.options.marker);\n        this._markerSearch._isMarkerSearch = true;\n      }\n\n      this.setLayer(this._layer);\n      map.on({\n        // \t\t'layeradd': this._onLayerAddRemove,\n        // \t\t'layerremove': this._onLayerAddRemove\n        'resize': this._handleAutoresize\n      }, this);\n      return this._container;\n    },\n    addTo: function addTo(map) {\n      if (this.options.container) {\n        this._container = this.onAdd(map);\n        this._wrapper = L.DomUtil.get(this.options.container);\n        this._wrapper.style.position = 'relative';\n\n        this._wrapper.appendChild(this._container);\n      } else L.Control.prototype.addTo.call(this, map);\n\n      return this;\n    },\n    onRemove: function onRemove(map) {\n      this._recordsCache = {}; // map.off({\n      // \t\t'layeradd': this._onLayerAddRemove,\n      // \t\t'layerremove': this._onLayerAddRemove\n      // \t}, this);\n\n      map.off({\n        // \t\t'layeradd': this._onLayerAddRemove,\n        // \t\t'layerremove': this._onLayerAddRemove\n        'resize': this._handleAutoresize\n      }, this);\n    },\n    // _onLayerAddRemove: function(e) {\n    // \t//without this, run setLayer also for each Markers!! to optimize!\n    // \tif(e.layer instanceof L.LayerGroup)\n    // \t\tif( L.stamp(e.layer) != L.stamp(this._layer) )\n    // \t\t\tthis.setLayer(e.layer);\n    // },\n    setLayer: function setLayer(layer) {\n      //set search layer at runtime\n      //this.options.layer = layer; //setting this, run only this._recordsFromLayer()\n      this._layer = layer;\n\n      this._layer.addTo(this._map);\n\n      return this;\n    },\n    showAlert: function showAlert(text) {\n      var self = this;\n      text = text || this.options.textErr;\n      this._alert.style.display = 'block';\n      this._alert.innerHTML = text;\n      clearTimeout(this.timerAlert);\n      this.timerAlert = setTimeout(function () {\n        self.hideAlert();\n      }, this.options.autoCollapseTime);\n      return this;\n    },\n    hideAlert: function hideAlert() {\n      this._alert.style.display = 'none';\n      return this;\n    },\n    cancel: function cancel() {\n      this._input.value = '';\n\n      this._handleKeypress({\n        keyCode: 8\n      }); //simulate backspace keypress\n\n\n      this._input.size = this._inputMinSize;\n\n      this._input.focus();\n\n      this._cancel.style.display = 'none';\n\n      this._hideTooltip();\n\n      this.fire('search:cancel');\n      return this;\n    },\n    expand: function expand(toggle) {\n      toggle = typeof toggle === 'boolean' ? toggle : true;\n      this._input.style.display = 'block';\n      L.DomUtil.addClass(this._container, 'search-exp');\n\n      if (toggle !== false) {\n        this._input.focus();\n\n        this._map.on('dragstart click', this.collapse, this);\n      }\n\n      this.fire('search:expanded');\n      return this;\n    },\n    collapse: function collapse() {\n      this._hideTooltip();\n\n      this.cancel();\n      this._alert.style.display = 'none';\n\n      this._input.blur();\n\n      if (this.options.collapsed) {\n        this._input.style.display = 'none';\n        this._cancel.style.display = 'none';\n        L.DomUtil.removeClass(this._container, 'search-exp');\n\n        if (this.options.hideMarkerOnCollapse) {\n          this._map.removeLayer(this._markerSearch);\n        }\n\n        this._map.off('dragstart click', this.collapse, this);\n      }\n\n      this.fire('search:collapsed');\n      return this;\n    },\n    collapseDelayed: function collapseDelayed() {\n      //collapse after delay, used on_input blur\n      var self = this;\n      if (!this.options.autoCollapse) return this;\n      clearTimeout(this.timerCollapse);\n      this.timerCollapse = setTimeout(function () {\n        self.collapse();\n      }, this.options.autoCollapseTime);\n      return this;\n    },\n    collapseDelayedStop: function collapseDelayedStop() {\n      clearTimeout(this.timerCollapse);\n      return this;\n    },\n    ////start DOM creations\n    _createAlert: function _createAlert(className) {\n      var alert = L.DomUtil.create('div', className, this._container);\n      alert.style.display = 'none';\n      L.DomEvent.on(alert, 'click', L.DomEvent.stop, this).on(alert, 'click', this.hideAlert, this);\n      return alert;\n    },\n    _createInput: function _createInput(text, className) {\n      var self = this;\n      var label = L.DomUtil.create('label', className, this._container);\n      var input = L.DomUtil.create('input', className, this._container);\n      input.type = 'text';\n      input.size = this._inputMinSize;\n      input.value = '';\n      input.autocomplete = 'off';\n      input.autocorrect = 'off';\n      input.autocapitalize = 'off';\n      input.placeholder = text;\n      input.style.display = 'none';\n      input.role = 'search';\n      input.id = input.role + input.type + input.size;\n      label.htmlFor = input.id;\n      label.style.display = 'none';\n      label.value = text;\n      L.DomEvent.disableClickPropagation(input).on(input, 'keyup', this._handleKeypress, this).on(input, 'paste', function (e) {\n        setTimeout(function (e) {\n          self._handleKeypress(e);\n        }, 10, e);\n      }, this).on(input, 'blur', this.collapseDelayed, this).on(input, 'focus', this.collapseDelayedStop, this);\n      return input;\n    },\n    _createCancel: function _createCancel(title, className) {\n      var cancel = L.DomUtil.create('a', className, this._container);\n      cancel.href = '#';\n      cancel.title = title;\n      cancel.style.display = 'none';\n      cancel.innerHTML = \"<span>&otimes;</span>\"; //imageless(see css)\n\n      L.DomEvent.on(cancel, 'click', L.DomEvent.stop, this).on(cancel, 'click', this.cancel, this);\n      return cancel;\n    },\n    _createButton: function _createButton(title, className) {\n      var button = L.DomUtil.create('a', className, this._container);\n      button.href = '#';\n      button.title = title;\n      L.DomEvent.on(button, 'click', L.DomEvent.stop, this).on(button, 'click', this._handleSubmit, this).on(button, 'focus', this.collapseDelayedStop, this).on(button, 'blur', this.collapseDelayed, this);\n      return button;\n    },\n    _createTooltip: function _createTooltip(className) {\n      var self = this;\n      var tool = L.DomUtil.create('ul', className, this._container);\n      tool.style.display = 'none';\n      L.DomEvent.disableClickPropagation(tool).on(tool, 'blur', this.collapseDelayed, this).on(tool, 'mousewheel', function (e) {\n        self.collapseDelayedStop();\n        L.DomEvent.stopPropagation(e); //disable zoom map\n      }, this).on(tool, 'mouseover', function (e) {\n        self.collapseDelayedStop();\n      }, this);\n      return tool;\n    },\n    _createTip: function _createTip(text, val) {\n      //val is object in recordCache, usually is Latlng\n      var tip;\n\n      if (this.options.buildTip) {\n        tip = this.options.buildTip.call(this, text, val); //custom tip node or html string\n\n        if (typeof tip === 'string') {\n          var tmpNode = L.DomUtil.create('div');\n          tmpNode.innerHTML = tip;\n          tip = tmpNode.firstChild;\n        }\n      } else {\n        tip = L.DomUtil.create('li', '');\n        tip.innerHTML = text;\n      }\n\n      L.DomUtil.addClass(tip, 'search-tip');\n      tip._text = text; //value replaced in this._input and used by _autoType\n\n      if (this.options.tipAutoSubmit) L.DomEvent.disableClickPropagation(tip).on(tip, 'click', L.DomEvent.stop, this).on(tip, 'click', function (e) {\n        this._input.value = text;\n\n        this._handleAutoresize();\n\n        this._input.focus();\n\n        this._hideTooltip();\n\n        this._handleSubmit();\n      }, this);\n      return tip;\n    },\n    //////end DOM creations\n    _getUrl: function _getUrl(text) {\n      return typeof this.options.url === 'function' ? this.options.url(text) : this.options.url;\n    },\n    _defaultFilterData: function _defaultFilterData(text, records) {\n      var I,\n          icase,\n          regSearch,\n          frecords = {};\n      text = text.replace(/[.*+?^${}()|[\\]\\\\]/g, ''); //sanitize remove all special characters\n\n      if (text === '') return [];\n      I = this.options.initial ? '^' : ''; //search only initial text\n\n      icase = !this.options.casesensitive ? 'i' : undefined;\n      regSearch = new RegExp(I + text, icase); //TODO use .filter or .map\n\n      for (var key in records) {\n        if (regSearch.test(key)) frecords[key] = records[key];\n      }\n\n      return frecords;\n    },\n    showTooltip: function showTooltip(records) {\n      this._countertips = 0;\n      this._tooltip.innerHTML = '';\n      this._tooltip.currentSelection = -1; //inizialized for _handleArrowSelect()\n\n      if (this.options.tooltipLimit) {\n        for (var key in records) //fill tooltip\n        {\n          if (this._countertips === this.options.tooltipLimit) break;\n          this._countertips++;\n\n          this._tooltip.appendChild(this._createTip(key, records[key]));\n        }\n      }\n\n      if (this._countertips > 0) {\n        this._tooltip.style.display = 'block';\n        if (this._autoTypeTmp) this._autoType();\n        this._autoTypeTmp = this.options.autoType; //reset default value\n      } else this._hideTooltip();\n\n      this._tooltip.scrollTop = 0;\n      return this._countertips;\n    },\n    _hideTooltip: function _hideTooltip() {\n      this._tooltip.style.display = 'none';\n      this._tooltip.innerHTML = '';\n      return 0;\n    },\n    _defaultFormatData: function _defaultFormatData(json) {\n      //default callback for format data to indexed data\n      var self = this,\n          propName = this.options.propertyName,\n          propLoc = this.options.propertyLoc,\n          i,\n          jsonret = {};\n      if (L.Util.isArray(propLoc)) for (i in json) {\n        jsonret[self._getPath(json[i], propName)] = L.latLng(json[i][propLoc[0]], json[i][propLoc[1]]);\n      } else for (i in json) {\n        jsonret[self._getPath(json[i], propName)] = L.latLng(self._getPath(json[i], propLoc));\n      } //TODO throw new Error(\"propertyName '\"+propName+\"' not found in JSON data\");\n\n      return jsonret;\n    },\n    _recordsFromJsonp: function _recordsFromJsonp(text, callAfter) {\n      //extract searched records from remote jsonp service\n      L.Control.Search.callJsonp = callAfter;\n      var script = L.DomUtil.create('script', 'leaflet-search-jsonp', document.getElementsByTagName('body')[0]),\n          url = L.Util.template(this._getUrl(text) + '&' + this.options.jsonpParam + '=L.Control.Search.callJsonp', {\n        s: text\n      }); //parsing url\n      //rnd = '&_='+Math.floor(Math.random()*10000);\n      //TODO add rnd param or randomize callback name! in recordsFromJsonp\n\n      script.type = 'text/javascript';\n      script.src = url;\n      return {\n        abort: function abort() {\n          script.parentNode.removeChild(script);\n        }\n      };\n    },\n    _recordsFromAjax: function _recordsFromAjax(text, callAfter) {\n      //Ajax request\n      if (window.XMLHttpRequest === undefined) {\n        window.XMLHttpRequest = function () {\n          try {\n            return new ActiveXObject(\"Microsoft.XMLHTTP.6.0\");\n          } catch (e1) {\n            try {\n              return new ActiveXObject(\"Microsoft.XMLHTTP.3.0\");\n            } catch (e2) {\n              throw new Error(\"XMLHttpRequest is not supported\");\n            }\n          }\n        };\n      }\n\n      var IE8or9 = L.Browser.ie && !window.atob && document.querySelector,\n          request = IE8or9 ? new XDomainRequest() : new XMLHttpRequest(),\n          url = L.Util.template(this._getUrl(text), {\n        s: text\n      }); //rnd = '&_='+Math.floor(Math.random()*10000);\n      //TODO add rnd param or randomize callback name! in recordsFromAjax\t\t\t\n\n      request.open(\"GET\", url);\n\n      request.onload = function () {\n        callAfter(JSON.parse(request.responseText));\n      };\n\n      request.onreadystatechange = function () {\n        if (request.readyState === 4 && request.status === 200) {\n          this.onload();\n        }\n      };\n\n      request.send();\n      return request;\n    },\n    _searchInLayer: function _searchInLayer(layer, retRecords, propName) {\n      var self = this,\n          loc;\n      if (layer instanceof L.Control.Search.Marker) return;\n\n      if (layer instanceof L.Marker || layer instanceof L.CircleMarker) {\n        if (self._getPath(layer.options, propName)) {\n          loc = layer.getLatLng();\n          loc.layer = layer;\n          retRecords[self._getPath(layer.options, propName)] = loc;\n        } else if (self._getPath(layer.feature.properties, propName)) {\n          loc = layer.getLatLng();\n          loc.layer = layer;\n          retRecords[self._getPath(layer.feature.properties, propName)] = loc;\n        } else {\n          //throw new Error(\"propertyName '\"+propName+\"' not found in marker\"); \n          console.warn(\"propertyName '\" + propName + \"' not found in marker\");\n        }\n      } else if (layer instanceof L.Path || layer instanceof L.Polyline || layer instanceof L.Polygon) {\n        if (self._getPath(layer.options, propName)) {\n          loc = layer.getBounds().getCenter();\n          loc.layer = layer;\n          retRecords[self._getPath(layer.options, propName)] = loc;\n        } else if (self._getPath(layer.feature.properties, propName)) {\n          loc = layer.getBounds().getCenter();\n          loc.layer = layer;\n          retRecords[self._getPath(layer.feature.properties, propName)] = loc;\n        } else {\n          //throw new Error(\"propertyName '\"+propName+\"' not found in shape\"); \n          console.warn(\"propertyName '\" + propName + \"' not found in shape\");\n        }\n      } else if (layer.hasOwnProperty('feature')) //GeoJSON\n        {\n          if (layer.feature.properties.hasOwnProperty(propName)) {\n            if (layer.getLatLng && typeof layer.getLatLng === 'function') {\n              loc = layer.getLatLng();\n              loc.layer = layer;\n              retRecords[layer.feature.properties[propName]] = loc;\n            } else if (layer.getBounds && typeof layer.getBounds === 'function') {\n              loc = layer.getBounds().getCenter();\n              loc.layer = layer;\n              retRecords[layer.feature.properties[propName]] = loc;\n            } else {\n              console.warn(\"Unknown type of Layer\");\n            }\n          } else {\n            //throw new Error(\"propertyName '\"+propName+\"' not found in feature\");\n            console.warn(\"propertyName '\" + propName + \"' not found in feature\");\n          }\n        } else if (layer instanceof L.LayerGroup) {\n        layer.eachLayer(function (layer) {\n          self._searchInLayer(layer, retRecords, propName);\n        });\n      }\n    },\n    _recordsFromLayer: function _recordsFromLayer() {\n      //return table: key,value from layer\n      var self = this,\n          retRecords = {},\n          propName = this.options.propertyName;\n\n      this._layer.eachLayer(function (layer) {\n        self._searchInLayer(layer, retRecords, propName);\n      });\n\n      return retRecords;\n    },\n    _autoType: function _autoType() {\n      //TODO implements autype without selection(useful for mobile device)\n      var start = this._input.value.length,\n          firstRecord = this._tooltip.firstChild ? this._tooltip.firstChild._text : '',\n          end = firstRecord.length;\n\n      if (firstRecord.indexOf(this._input.value) === 0) {\n        // If prefix match\n        this._input.value = firstRecord;\n\n        this._handleAutoresize();\n\n        if (this._input.createTextRange) {\n          var selRange = this._input.createTextRange();\n\n          selRange.collapse(true);\n          selRange.moveStart('character', start);\n          selRange.moveEnd('character', end);\n          selRange.select();\n        } else if (this._input.setSelectionRange) {\n          this._input.setSelectionRange(start, end);\n        } else if (this._input.selectionStart) {\n          this._input.selectionStart = start;\n          this._input.selectionEnd = end;\n        }\n      }\n    },\n    _hideAutoType: function _hideAutoType() {\n      // deselect text:\n      var sel;\n\n      if ((sel = this._input.selection) && sel.empty) {\n        sel.empty();\n      } else if (this._input.createTextRange) {\n        sel = this._input.createTextRange();\n        sel.collapse(true);\n        var end = this._input.value.length;\n        sel.moveStart('character', end);\n        sel.moveEnd('character', end);\n        sel.select();\n      } else {\n        if (this._input.getSelection) {\n          this._input.getSelection().removeAllRanges();\n        }\n\n        this._input.selectionStart = this._input.selectionEnd;\n      }\n    },\n    _handleKeypress: function _handleKeypress(e) {\n      //run _input keyup event\n      var self = this;\n\n      switch (e.keyCode) {\n        case 27:\n          //Esc\n          this.collapse();\n          break;\n\n        case 13:\n          //Enter\n          if (this._countertips == 1 || this.options.firstTipSubmit && this._countertips > 0) {\n            if (this._tooltip.currentSelection == -1) {\n              this._handleArrowSelect(1);\n            }\n          }\n\n          this._handleSubmit(); //do search\n\n\n          break;\n\n        case 38:\n          //Up\n          this._handleArrowSelect(-1);\n\n          break;\n\n        case 40:\n          //Down\n          this._handleArrowSelect(1);\n\n          break;\n\n        case 8: //Backspace\n\n        case 45: //Insert\n\n        case 46:\n          //Delete\n          this._autoTypeTmp = false; //disable temporarily autoType\n\n          break;\n\n        case 37: //Left\n\n        case 39: //Right\n\n        case 16: //Shift\n\n        case 17: //Ctrl\n\n        case 35: //End\n\n        case 36:\n          //Home\n          break;\n\n        default:\n          //All keys\n          if (this._input.value.length) this._cancel.style.display = 'block';else this._cancel.style.display = 'none';\n\n          if (this._input.value.length >= this.options.minLength) {\n            clearTimeout(this.timerKeypress); //cancel last search request while type in\t\t\t\t\n\n            this.timerKeypress = setTimeout(function () {\n              //delay before request, for limit jsonp/ajax request\n              self._fillRecordsCache();\n            }, this.options.delayType);\n          } else this._hideTooltip();\n\n      }\n\n      this._handleAutoresize();\n    },\n    searchText: function searchText(text) {\n      var code = text.charCodeAt(text.length);\n      this._input.value = text;\n      this._input.style.display = 'block';\n      L.DomUtil.addClass(this._container, 'search-exp');\n      this._autoTypeTmp = false;\n\n      this._handleKeypress({\n        keyCode: code\n      });\n    },\n    _fillRecordsCache: function _fillRecordsCache() {\n      var self = this,\n          inputText = this._input.value,\n          records;\n      if (this._curReq && this._curReq.abort) this._curReq.abort(); //abort previous requests\n\n      L.DomUtil.addClass(this._container, 'search-load');\n\n      if (this.options.layer) {\n        //TODO _recordsFromLayer must return array of objects, formatted from _formatData\n        this._recordsCache = this._recordsFromLayer();\n        records = this._filterData(this._input.value, this._recordsCache);\n        this.showTooltip(records);\n        L.DomUtil.removeClass(this._container, 'search-load');\n      } else {\n        if (this.options.sourceData) this._retrieveData = this.options.sourceData;else if (this.options.url) //jsonp or ajax\n          this._retrieveData = this.options.jsonpParam ? this._recordsFromJsonp : this._recordsFromAjax;\n        this._curReq = this._retrieveData.call(this, inputText, function (data) {\n          self._recordsCache = self._formatData.call(self, data); //TODO refact!\n\n          if (self.options.sourceData) records = self._filterData(self._input.value, self._recordsCache);else records = self._recordsCache;\n          self.showTooltip(records);\n          L.DomUtil.removeClass(self._container, 'search-load');\n        });\n      }\n    },\n    _handleAutoresize: function _handleAutoresize() {\n      var maxWidth;\n\n      if (this._input.style.maxWidth !== this._map._container.offsetWidth) {\n        maxWidth = this._map._container.clientWidth; // other side margin + padding + width border + width search-button + width search-cancel\n\n        maxWidth -= 10 + 20 + 1 + 30 + 22;\n        this._input.style.maxWidth = maxWidth.toString() + 'px';\n      }\n\n      if (this.options.autoResize && this._container.offsetWidth + 20 < this._map._container.offsetWidth) {\n        this._input.size = this._input.value.length < this._inputMinSize ? this._inputMinSize : this._input.value.length;\n      }\n    },\n    _handleArrowSelect: function _handleArrowSelect(velocity) {\n      var searchTips = this._tooltip.hasChildNodes() ? this._tooltip.childNodes : [];\n\n      for (i = 0; i < searchTips.length; i++) {\n        L.DomUtil.removeClass(searchTips[i], 'search-tip-select');\n      }\n\n      if (velocity == 1 && this._tooltip.currentSelection >= searchTips.length - 1) {\n        // If at end of list.\n        L.DomUtil.addClass(searchTips[this._tooltip.currentSelection], 'search-tip-select');\n      } else if (velocity == -1 && this._tooltip.currentSelection <= 0) {\n        // Going back up to the search box.\n        this._tooltip.currentSelection = -1;\n      } else if (this._tooltip.style.display != 'none') {\n        this._tooltip.currentSelection += velocity;\n        L.DomUtil.addClass(searchTips[this._tooltip.currentSelection], 'search-tip-select');\n        this._input.value = searchTips[this._tooltip.currentSelection]._text; // scroll:\n\n        var tipOffsetTop = searchTips[this._tooltip.currentSelection].offsetTop;\n\n        if (tipOffsetTop + searchTips[this._tooltip.currentSelection].clientHeight >= this._tooltip.scrollTop + this._tooltip.clientHeight) {\n          this._tooltip.scrollTop = tipOffsetTop - this._tooltip.clientHeight + searchTips[this._tooltip.currentSelection].clientHeight;\n        } else if (tipOffsetTop <= this._tooltip.scrollTop) {\n          this._tooltip.scrollTop = tipOffsetTop;\n        }\n      }\n    },\n    _handleSubmit: function _handleSubmit() {\n      //button and tooltip click and enter submit\n      this._hideAutoType();\n\n      this.hideAlert();\n\n      this._hideTooltip();\n\n      if (this._input.style.display == 'none') //on first click show _input only\n        this.expand();else {\n        if (this._input.value === '') //hide _input only\n          this.collapse();else {\n          var loc = this._getLocation(this._input.value);\n\n          if (loc === false) this.showAlert();else {\n            this.showLocation(loc, this._input.value);\n            this.fire('search:locationfound', {\n              latlng: loc,\n              text: this._input.value,\n              layer: loc.layer ? loc.layer : null\n            });\n          }\n        }\n      }\n    },\n    _getLocation: function _getLocation(key) {\n      //extract latlng from _recordsCache\n      if (this._recordsCache.hasOwnProperty(key)) return this._recordsCache[key]; //then after use .loc attribute\n      else return false;\n    },\n    _defaultMoveToLocation: function _defaultMoveToLocation(latlng, title, map) {\n      if (this.options.zoom) this._map.setView(latlng, this.options.zoom);else this._map.panTo(latlng);\n    },\n    showLocation: function showLocation(latlng, title) {\n      //set location on map from _recordsCache\n      var self = this;\n\n      self._map.once('moveend zoomend', function (e) {\n        if (self._markerSearch) {\n          self._markerSearch.addTo(self._map).setLatLng(latlng);\n        }\n      });\n\n      self._moveToLocation(latlng, title, self._map); //FIXME autoCollapse option hide self._markerSearch before visualized!!\n\n\n      if (self.options.autoCollapse) self.collapse();\n      return self;\n    }\n  });\n  L.Control.Search.Marker = L.Marker.extend({\n    includes: L.version[0] === '1' ? L.Evented.prototype : L.Mixin.Events,\n    options: {\n      icon: new L.Icon.Default(),\n      animate: true,\n      circle: {\n        radius: 10,\n        weight: 3,\n        color: '#e03',\n        stroke: true,\n        fill: false\n      }\n    },\n    initialize: function initialize(latlng, options) {\n      L.setOptions(this, options);\n      if (options.icon === true) options.icon = new L.Icon.Default();\n      L.Marker.prototype.initialize.call(this, latlng, options);\n      if (L.Control.Search.prototype._isObject(this.options.circle)) this._circleLoc = new L.CircleMarker(latlng, this.options.circle);\n    },\n    onAdd: function onAdd(map) {\n      L.Marker.prototype.onAdd.call(this, map);\n\n      if (this._circleLoc) {\n        map.addLayer(this._circleLoc);\n        if (this.options.animate) this.animate();\n      }\n    },\n    onRemove: function onRemove(map) {\n      L.Marker.prototype.onRemove.call(this, map);\n      if (this._circleLoc) map.removeLayer(this._circleLoc);\n    },\n    setLatLng: function setLatLng(latlng) {\n      L.Marker.prototype.setLatLng.call(this, latlng);\n      if (this._circleLoc) this._circleLoc.setLatLng(latlng);\n      return this;\n    },\n    _initIcon: function _initIcon() {\n      if (this.options.icon) L.Marker.prototype._initIcon.call(this);\n    },\n    _removeIcon: function _removeIcon() {\n      if (this.options.icon) L.Marker.prototype._removeIcon.call(this);\n    },\n    animate: function animate() {\n      //TODO refact animate() more smooth! like this: http://goo.gl/DDlRs\n      if (this._circleLoc) {\n        var circle = this._circleLoc,\n            tInt = 200,\n            //time interval\n        ss = 5,\n            //frames\n        mr = parseInt(circle._radius / ss),\n            oldrad = this.options.circle.radius,\n            newrad = circle._radius * 2,\n            acc = 0;\n        circle._timerAnimLoc = setInterval(function () {\n          acc += 0.5;\n          mr += acc; //adding acceleration\n\n          newrad -= mr;\n          circle.setRadius(newrad);\n\n          if (newrad < oldrad) {\n            clearInterval(circle._timerAnimLoc);\n            circle.setRadius(oldrad); //reset radius\n            //if(typeof afterAnimCall == 'function')\n            //afterAnimCall();\n            //TODO use create event 'animateEnd' in L.Control.Search.Marker \n          }\n        }, tInt);\n      }\n\n      return this;\n    }\n  });\n  L.Map.addInitHook(function () {\n    if (this.options.searchControl) {\n      this.searchControl = L.control.search(this.options.searchControl);\n      this.addControl(this.searchControl);\n    }\n  });\n\n  L.control.search = function (options) {\n    return new L.Control.Search(options);\n  };\n\n  return L.Control.Search;\n});","map":null,"metadata":{},"sourceType":"script"}